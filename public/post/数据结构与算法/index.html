<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="绪论\r数据结构在学什么？\r如何使用数据来表示生活中的问题. 数据结构的基本概念\r数据：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。 数据元素：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。 数据对象:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。 数据结构:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。 数据类型：一个值的集合和定义在此集合上的一组操作的总称。 原子类型：其值不可再分的数据类型，如bool类型，int类型 结构类型：其值可以再分解为若干成分(分量)的数据类型 struct Coordinate { int x; int y; } 抽象数据类型(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作. 数据结构的三要素\r逻辑结构\r集合：各个元素同属于一个集合，并无其他关系 线性结构：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。 树形结构：数据元素之间的{%label 一对多 green%}的关系。 图结构:数据元素之间是{%label 多对多的关系 green%} 数据的运算\r结合逻辑结构，实际需求来定义基本运算。 物理结构(存储结构)\r如何用计算机实现这种数据结构 顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。 链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%} 散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。 运算的定义是针对逻辑结构的，指出运算的功能。 运算的实现是针对存储结构的，指出运算的具体操作步骤。 算法的基本概念\r算法(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.">
<title>数据结构与算法</title>

<link rel='canonical' href='http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>

<link rel="stylesheet" href="/scss/style.min.e8c7fca7d1c9294aa7a4f3426c225ee26540f7d94e39be0b5a4a5c8a49ca5a25.css"><meta property='og:title' content="数据结构与算法">
<meta property='og:description' content="绪论\r数据结构在学什么？\r如何使用数据来表示生活中的问题. 数据结构的基本概念\r数据：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。 数据元素：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。 数据对象:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。 数据结构:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。 数据类型：一个值的集合和定义在此集合上的一组操作的总称。 原子类型：其值不可再分的数据类型，如bool类型，int类型 结构类型：其值可以再分解为若干成分(分量)的数据类型 struct Coordinate { int x; int y; } 抽象数据类型(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作. 数据结构的三要素\r逻辑结构\r集合：各个元素同属于一个集合，并无其他关系 线性结构：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。 树形结构：数据元素之间的{%label 一对多 green%}的关系。 图结构:数据元素之间是{%label 多对多的关系 green%} 数据的运算\r结合逻辑结构，实际需求来定义基本运算。 物理结构(存储结构)\r如何用计算机实现这种数据结构 顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。 链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%} 散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。 运算的定义是针对逻辑结构的，指出运算的功能。 运算的实现是针对存储结构的，指出运算的具体操作步骤。 算法的基本概念\r算法(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.">
<meta property='og:url' content='http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>
<meta property='og:site_name' content='马嘉路个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-08-18T21:11:11&#43;08:00'/><meta property='article:modified_time' content='2024-08-18T21:11:11&#43;08:00'/>
<meta name="twitter:title" content="数据结构与算法">
<meta name="twitter:description" content="绪论\r数据结构在学什么？\r如何使用数据来表示生活中的问题. 数据结构的基本概念\r数据：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。 数据元素：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。 数据对象:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。 数据结构:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。 数据类型：一个值的集合和定义在此集合上的一组操作的总称。 原子类型：其值不可再分的数据类型，如bool类型，int类型 结构类型：其值可以再分解为若干成分(分量)的数据类型 struct Coordinate { int x; int y; } 抽象数据类型(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作. 数据结构的三要素\r逻辑结构\r集合：各个元素同属于一个集合，并无其他关系 线性结构：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。 树形结构：数据元素之间的{%label 一对多 green%}的关系。 图结构:数据元素之间是{%label 多对多的关系 green%} 数据的运算\r结合逻辑结构，实际需求来定义基本运算。 物理结构(存储结构)\r如何用计算机实现这种数据结构 顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。 链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%} 散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。 运算的定义是针对逻辑结构的，指出运算的功能。 运算的实现是针对存储结构的，指出运算的具体操作步骤。 算法的基本概念\r算法(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.">
    <link rel="shortcut icon" href="/favicon.ico" />

  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/my_hu5854369107718497747.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">马嘉路个人博客</a></h1>
            <h2 class="site-description">长风破浪会有时</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 18, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    13 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="绪论">绪论
</h1><h2 id="数据结构在学什么"><strong>数据结构在学什么？</strong>
</h2><p>如何使用数据来表示生活中的问题.</p>
<h2 id="数据结构的基本概念">数据结构的基本概念
</h2><p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%92%8C%E6%95%B0%E6%8D%AE%E9%A1%B9.png"
	width="901"
	height="293"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%92%8C%E6%95%B0%E6%8D%AE%E9%A1%B9_hu10441977479066037078.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%92%8C%E6%95%B0%E6%8D%AE%E9%A1%B9_hu11765884613774761603.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="307"
		data-flex-basis="738px"
	
></p>
<p><strong>数据</strong>：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。</p>
<p><strong>数据元素</strong>：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1.png"
	width="3508"
	height="2480"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1_hu18189302494536034091.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1_hu16913164030830294808.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="141"
		data-flex-basis="339px"
	
></p>
<p><strong>数据对象</strong>:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据结构</strong>:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。</p>
<p><strong>数据类型</strong>：一个值的集合和定义在此集合上的一组操作的总称。</p>
<ul>
<li>原子类型：其值不可再分的数据类型，如bool类型，int类型</li>
<li>结构类型：其值可以再分解为若干成分(分量)的数据类型</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Coordinate</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>抽象数据类型</strong>(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作.</p>
<h2 id="数据结构的三要素">数据结构的三要素
</h2><h3 id="逻辑结构">逻辑结构
</h3><p><strong>集合</strong>：各个元素同属于一个集合，并无其他关系</p>
<p><strong>线性结构</strong>：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。</p>
<p><strong>树形结构</strong>：数据元素之间的{%label 一对多 green%}的关系。</p>
<p><strong>图结构</strong>:数据元素之间是{%label 多对多的关系 green%}</p>
<h3 id="数据的运算">数据的运算
</h3><p>结合逻辑结构，实际需求来定义基本运算。</p>
<h3 id="物理结构存储结构">物理结构(存储结构)
</h3><p>如何用计算机实现这种数据结构</p>
<ul>
<li>顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。</li>
<li>链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%}</li>
<li>散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。</li>
</ul>
<blockquote>
<p>运算的定义是针对逻辑结构的，指出运算的功能。</p>
<p>运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
</blockquote>
<h2 id="算法的基本概念">算法的基本概念
</h2><p><strong>算法</strong>(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.</p>
<p><strong>算法的特性</strong>:</p>
<ul>
<li>有穷性:一个算法必须总在执行有穷步之后结束,且每一步都可在又穷时间内完成.</li>
<li>确定性:算法中每条指令必须有确切的含义,对于{%label 相同的输入 green%}只能得到{%label 相同的输出 green%}.</li>
<li>可行性:算法中描述的操作都可以通过已经实现的{%label 基本运算执行有限次 green%}来实现.</li>
<li>输入:一个算法有{%label 零个或多个输入 green%},这些输入取自于某个特定的对象的集合.</li>
<li>输出:一个算法有{%label 一个或多个输出 green%},这些输出是与输入有着某种特定关系的量.</li>
</ul>
<p><strong>&ldquo;好&quot;算法特质</strong></p>
<ul>
<li>正确性:正确地解决问题</li>
<li>可读性:算法应该具有良好的可读性,以帮助人们理解.</li>
<li>健壮性:输入非法数据时,算法能够适当地做出反映或进行处理,而不会产生莫名奇妙的输出结果</li>
<li>高效率和低存储量需求:时间复杂度和空间复杂度低</li>
</ul>
<h2 id="算法的时间复杂度">算法的时间复杂度
</h2><blockquote>
<p><strong>同阶无穷大</strong></p>
<p>$O(1)&lt;O(log n)&lt;O(n)&lt;O(nlog n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$</p>
</blockquote>
<blockquote>
<p><strong>小结论</strong></p>
<ol>
<li>顺序执行的代码只会影响常数项,可以忽略.</li>
<li>只需挑循环中的<strong>一个基本操作</strong>分析它的执行次数与n的关系即可</li>
<li>如果有多层嵌套循环,只需关注最深层循环循环了几次</li>
</ol>
</blockquote>
<p><strong>最好/最坏/平均时间复杂度</strong></p>
<h2 id="算法的空间复杂度">算法的空间复杂度
</h2><p><strong>算法原地工作</strong>:无论问题规模怎么变,算法所需的内存空间都是固定的常量,算法的空间复杂度为$O(1)$</p>
<p><strong>递归算法</strong>:通常为递归调用的深度</p>
<h1 id="线性表">线性表
</h1><h2 id="线性表的定义和基本操作">线性表的定义和基本操作
</h2><p><strong>线性表</strong>:具有{%label 相同数据类型 green%}的n(n&gt;=0)个{%label 数据元素 green%}的{%label 有限序列 green%},其中n为{%label 表长 green%},当n=0时线性表是一个{%label 空表 green%}.若用L命名线性表,则其一般表示为</p>
<p>$$L = (a_1,a_2,a_i,a_{i+1},&hellip;a_n)$$</p>
<blockquote>
<p>$a_i$是线性表中的&quot;第i个&quot;元素,线性表中的位序</p>
<p>$a_1$是表头元素,$a_n$是表尾元素</p>
<p>除第一个元素外,每个元素有且仅有一个直接前驱,除最后一个元素外,每个元素有且仅有一个直接后继.</p>
</blockquote>
<p><strong>基本操作</strong></p>
<ul>
<li>InitList(&amp;L):初始化表.构造一个空的线性表L,分配内存空间</li>
<li>DestroyList(%L):销毁操作.销毁线性表,并释放线性表L所占用的内存空间</li>
<li>ListInsert(&amp;L,i,e):插入操作.在线性表的第i个位置插入指定元素e</li>
<li>ListDelete(&amp;L,i,&amp;e):删除操作.删除表L中第i个位置的元素,并用e返回删除元素的值.</li>
<li>LocateElement(L,e):按值查找操作.在表L中查找具有给定关键字值的元素.</li>
<li>GetElem(L,i):按位查找操作,获取表L中第i个位置的元素的值.</li>
<li>Lengeh(L):求表长.返回线性表L的长度,即L中数据元素的个数.</li>
<li>PrintList(L):输出操作.按前后顺序输出线性表L的所有元素值.</li>
<li>Empty(L):判空操作.若L为空表,则返回true,否则返回false</li>
</ul>
<h2 id="顺序表的定义">顺序表的定义
</h2><p><strong>顺序表</strong>:用{%label 顺序存储 green%}的方式实现线性表.</p>
<p><strong>实现方式</strong></p>
<ul>
<li>静态分配</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define MaxSize 10 </span><span style="color:#75715e">// 定义最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> data[MaxSize];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>    } SqList;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 基本操作：初始化一个顺序表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitList</span>(SqList <span style="color:#f92672">&amp;</span>L)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MaxSize; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        L.data[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 将所有数据元素设置为默认初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>      L.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 顺序表的初始长度为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      SqList L;    <span style="color:#75715e">// 声明一个顺序表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      InitList(L); <span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }									<span style="color:#75715e">//顺序表的类型定义(静态分配方式)
</span></span></span></code></pre></div><ul>
<li>动态分配</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define InitSize 10           </span><span style="color:#75715e">// 默认的最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SeqList</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data;                  <span style="color:#75715e">// 指示动态分配数组的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> MaxSize;                <span style="color:#75715e">// 顺序表的最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> length;                 <span style="color:#75715e">// 顺序表的当前长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitList</span>(SeqList <span style="color:#f92672">&amp;</span>L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  L.data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)malloc(InitSize <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));     <span style="color:#75715e">// 分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  L.MaxSize <span style="color:#f92672">=</span> InitSize;                               <span style="color:#75715e">// 初始化最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  L.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                                       <span style="color:#75715e">// 初始化当前长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 增加动态数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">IncreaseSize</span>(SeqList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> L.data;                                    <span style="color:#75715e">// 保存原数组指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  L.data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)malloc((L.MaxSize <span style="color:#f92672">+</span> len) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)); <span style="color:#75715e">// 分配新的内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L.length; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    L.data[i] <span style="color:#f92672">=</span> p[i];                                 <span style="color:#75715e">// 将原数组元素拷贝到新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  L.MaxSize <span style="color:#f92672">=</span> L.MaxSize <span style="color:#f92672">+</span> len;
</span></span><span style="display:flex;"><span>  free(p);                                            <span style="color:#75715e">// 释放原数组的内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>顺序表的特点</strong></p>
<ul>
<li>随机访问:即可以在O(1)时间内找到第i个元素</li>
<li>存储密度高,每个节点只存储数据元素</li>
<li>拓展容量不方便(即便采用动态分配的方式实现,拓展长度的时间复杂度也比较高)</li>
<li>插入,删除操作不方便,需要移动大量元素.</li>
</ul>
<h2 id="顺序表的插入删除">顺序表的插入删除
</h2><p><strong>插入</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 基本操作：在L的位序i处插入元素e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ListInsert</span>(SqList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> L.length; j <span style="color:#f92672">&gt;=</span> i; j<span style="color:#f92672">--</span>){   <span style="color:#75715e">// 将第i个元素及之后的元素后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    L.data[j] <span style="color:#f92672">=</span> L.data[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  L.data[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> e;                    <span style="color:#75715e">// 在位序i处放入e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  L.length<span style="color:#f92672">++</span>;                           <span style="color:#75715e">// 顺序表长度加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 增加健壮性后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ListInsert</span>(SqList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L.length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (L.length <span style="color:#f92672">&gt;=</span> MaxSize)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> L.length; j <span style="color:#f92672">&gt;=</span> i; j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    L.data[j] <span style="color:#f92672">=</span> L.data[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  L.data[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>  L.length<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>时间复杂度分析:</p>
<ul>
<li>最好情况:新元素插入到表尾,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)</li>
<li>最坏情况:新元素插入到表头,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);</li>
<li>平均情况:假设新元素插入到任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)</li>
</ul>
</blockquote>
<p><strong>删除</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ListDelete</span>(SqList <span style="color:#f92672">&amp;</span>L,<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">||</span>i<span style="color:#f92672">&gt;</span>L.length)			<span style="color:#75715e">// 判断i的范围是否有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">=</span>L.data[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]				<span style="color:#75715e">// 将被删除的元素赋值给e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>i;j<span style="color:#f92672">&lt;</span>L.length;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        L.data[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>L.data[j];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    L.length<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    SqList L;		<span style="color:#75715e">//声明一个顺序表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InitList(L);    <span style="color:#75715e">// 初始化顺序表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 此处省略一些代码,插入几个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// 用变量e把删除的元素带回来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(ListDelete(L,<span style="color:#ae81ff">3</span>,e))
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;已删除第3个元素,删除元素值为=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,e);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;位序i不合法,删除失败</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>时间复杂度分析:</p>
<ul>
<li>最好情况:删除表尾的元素,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)</li>
<li>最坏情况:删除表头的元素,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);</li>
<li>平均情况:删除任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)</li>
</ul>
</blockquote>
<h2 id="顺序表的查找">顺序表的查找
</h2><p><strong>按位查找</strong></p>
<p><code>GetElem(L,i)</code>:按位查找操作.获取表L中第i个位置的元素的值.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 静态方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MaxSize 10  </span><span style="color:#75715e">// 定义最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SqList</span>{
</span></span><span style="display:flex;"><span>    ElemType data[MaxSize];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>ElemType <span style="color:#a6e22e">GetElem</span>(SqList L, <span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> L.data[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 动态方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define InitSize 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SeqList</span>{
</span></span><span style="display:flex;"><span>    ElemType <span style="color:#f92672">*</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> MaxSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>ElemType <span style="color:#a6e22e">GetElem</span>(SeqList L, <span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> L.data[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]			<span style="color:#75715e">// 和访问普通数组的方法一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p><strong>时间复杂度</strong>:O(1)</p>
</blockquote>
<p><strong>按值查找</strong></p>
<p><code>LocateElem(L,e)</code>:按值查找操作.在表L中查找具有给定关键字值的元素.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define InitSize 10   </span><span style="color:#75715e">// 顺序表的初始长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    ElemType <span style="color:#f92672">*</span>data;	  <span style="color:#75715e">// 指示动态分配数组的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> MaxSize;	  <span style="color:#75715e">// 顺序表的最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;		  <span style="color:#75715e">// 顺序表的当前长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SeqList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在顺序表L中查找第一个元素值等于e的元素,并返回其位序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LocateElem</span>(SeqList L, ElemType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>L.length;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(L.data[i]<span style="color:#f92672">==</span>e)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意:结构类型的比较不能用==比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 需要依次对比各个分量来判断两个结构体是否相等
</span></span></span></code></pre></div><blockquote>
<p>时间复杂度分析:</p>
<p>最好情况:O(1)</p>
<p>最坏情况:O(n)</p>
<p>平均情况:O(n)</p>
</blockquote>
<h2 id="单链表的定义">单链表的定义
</h2><p><strong>单链表</strong>:每个结点除了存放数据元素外,还要存储指向下一个节点的指针.</p>
<ul>
<li>优点：不要求大片连续空间，改容量方便。</li>
<li>缺点：不可随机存储，要耗费一定空间存放指针。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>
</span></span><span style="display:flex;"><span>{                     <span style="color:#75715e">// 定义单链表结点类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ElemType data;      <span style="color:#75715e">// 每个结点存放一个数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next; <span style="color:#75715e">// 指针指向下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 增加一个新结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>));
</span></span></code></pre></div><hr>
<p><strong>使用typedef关键字来简化代码</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{
</span></span><span style="display:flex;"><span>  ElemType data;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LNode, <span style="color:#f92672">*</span>LinkList;
</span></span></code></pre></div><p>要表示一个单链表时,只需声明一个{%label 头指针 green%}L,指向单链表的第一个结点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LNode <span style="color:#f92672">*</span>L;			<span style="color:#75715e">//声明一个指向单链表第一个结点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者也可以使用如下方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LinkList L;			<span style="color:#75715e">//声明一个指向单链表第一个结点的指针
</span></span></span></code></pre></div><p>LNode *L和LinkList L本质是一样的,不过前者更强调单独的一个结点,而后者更强调这是一个单链表整体.</p>
<p><strong>不带头结点的单链表</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{			<span style="color:#75715e">//定义单链表结点类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ElemType data;				<span style="color:#75715e">//每个结点存放一个数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;			<span style="color:#75715e">//指针指向下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LNode, <span style="color:#f92672">*</span>LinkList;				<span style="color:#75715e">//将struct LNode 取别名为LNode,将struct LNode *取别名为LinkList
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化一个空的单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InitList</span>(LinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> NULL;			<span style="color:#75715e">//空表,暂时还没有任何结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断单链表是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Empty</span>(LinkList L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (L<span style="color:#f92672">==</span>NULL);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 测试一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> test {
</span></span><span style="display:flex;"><span>    LinkList L;			<span style="color:#75715e">//声明一个指向单链表的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化一个空表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InitList(L);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 后续代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>带头结点的单链表</strong>:推荐!!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{				<span style="color:#75715e">//定义单链表结点类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ElemType data;					<span style="color:#75715e">//每个结点存放一个数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;				<span style="color:#75715e">//指针指向下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LNode, <span style="color:#f92672">*</span>LinkList;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化一个单链表(带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InitList</span>(LinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));		<span style="color:#75715e">//分配一个头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(L <span style="color:#f92672">==</span> NULL)						<span style="color:#75715e">// 内存不足,分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;						<span style="color:#75715e">//头结点之后暂时还没有结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>    LinkList L;							<span style="color:#75715e">//声明一个指向单链表的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化一个空表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InitList(L);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//... 后续代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="单链表的插入删除">单链表的插入删除
</h2><p><strong>带头结点</strong></p>
<p>ListInsert(&amp;L,i,e):插入操作，在表L中第i个位置插入指定元素e</p>
<p>需要找到第i-1个结点，将新结点插入其中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 定义一个单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LNode, <span style="color:#f92672">*</span>LinkList;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在第i个位置插入元素e(带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ListInsert</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> i, ElemType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>p;			<span style="color:#75715e">//指针p指向当前扫描到的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;			<span style="color:#75715e">//当前p指向的是第几个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> L;				<span style="color:#75715e">//L指向头结点，头结点是第0个结点(不存数据)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//循环找到第i-1个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++:</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)			<span style="color:#75715e">//i值不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>e;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>s;		<span style="color:#75715e">//将结点s连到p之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;     <span style="color:#75715e">//插入成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p><strong>时间复杂度分析</strong></p>
<p>最好情况：在表头插入，O(1)</p>
<p>最坏情况/平均情况: O(n)</p>
</blockquote>
<p><strong>不带头结点</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 定义一个单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LNode, <span style="color:#f92672">*</span>LinkList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//按位序插入(不带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ListInsert</span>(LinkList <span style="color:#f92672">&amp;</span>L,<span style="color:#66d9ef">int</span> i, ElemType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入第一个结点的操作与其他结点的不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>        s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L;
</span></span><span style="display:flex;"><span>        L <span style="color:#f92672">=</span> s;     <span style="color:#75715e">// 头指针指向新结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>p;		<span style="color:#75715e">//指针p指向当前扫描到的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;		<span style="color:#75715e">//当前p指向的是第几个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> L;			<span style="color:#75715e">//p指向第1个结点(注意：不是头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//循环找到第i-1个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)			<span style="color:#75715e">//i值不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;		<span style="color:#75715e">//插入成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>指定结点的后插操作</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 后插操作：在结点p之后出入元素e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 时间复杂度,O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InsertNextNode</span> (LNode <span style="color:#f92672">*</span>p, ElemType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>NULL)		<span style="color:#75715e">//内存分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;		<span style="color:#75715e">//用结点s存放数据元素e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;		<span style="color:#75715e">//将结点s连到p之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>指定结点的前插操作</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 前插操作：在p结点之前插入元素e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 传入头指针，遍历整个链表，找到p结点的前驱节点，在其之后插入e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 时间复杂度O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//bool InsertPriorNode(LinkList L, LNode *p, ElemType e)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 第二种方式，先在p结点之后插入新结点，再将p的元素赋值给新结点，将e赋值给p结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InsertPriorNode</span>(LNode <span style="color:#f92672">*</span>p,ElemType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>NULL)			<span style="color:#75715e">//内存分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;		<span style="color:#75715e">//新结点s连到p之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>data;	<span style="color:#75715e">//将p中元素复制到s中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>e;			<span style="color:#75715e">//将p中元素覆盖为e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;		<span style="color:#75715e">//前插成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>按位序删除</strong>(带头结点)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ListDelete</span>(LinkList <span style="color:#f92672">&amp;</span>L,<span style="color:#66d9ef">int</span> i,ElemType <span style="color:#f92672">&amp;</span>e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>p;		<span style="color:#75715e">//指针p指向当前扫描到的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;		<span style="color:#75715e">//当前p指向的是第几个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> L;			<span style="color:#75715e">//L指向头结点,头结点是第0个结点(不存数据)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;</span> j<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)		<span style="color:#75715e">//i值不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">==</span>NULL)	<span style="color:#75715e">//第i-1结点之后已无其他结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;	<span style="color:#75715e">//令q指向被删除的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    e <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>data;		<span style="color:#75715e">//用e返回元素的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>q<span style="color:#f92672">-&gt;</span>next;	<span style="color:#75715e">//将*q结点从链中断开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    free(q);			<span style="color:#75715e">//释放结点的存储空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;		<span style="color:#75715e">//删除成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p>最好情况:O(1)</p>
<p>最坏情况/平均情况:O(n)</p>
</blockquote>
<p><strong>指定结点的删除</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 删除指定的结点p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeleteNode</span>(LNode <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;		<span style="color:#75715e">//令q指向*p的后继节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data;	<span style="color:#75715e">//和后继节点交换数据域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>q<span style="color:#f92672">-&gt;</span>next;		<span style="color:#75715e">//将*q结点从链中断开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    free(q);				<span style="color:#75715e">//释放后继结点的存储空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果*p是最后一个节点的话,不能ci&#39;a&#39;y
</span></span></span></code></pre></div><h2 id="单链表的查找">单链表的查找
</h2><p><strong>按位查找</strong></p>
<p>GetElem(L,i):按位查找，获取表L中第i个位置的元素.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//按位查找，返回第i个元素(带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LNode <span style="color:#f92672">*</span><span style="color:#a6e22e">GetElem</span>(LinkList L,<span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>p;		<span style="color:#75715e">//指针p指向当前扫描到的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;		<span style="color:#75715e">//当前p指向的是第几个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> L;			<span style="color:#75715e">//L指向头结点，头结点是第0个结点，不存数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!==</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i){
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>最好情况:O(1)</p>
<p>最差情况/平均情况:O(n)</p>
</blockquote>
<p><strong>按值查找</strong></p>
<p>LocateElem(L,e):按值查找，再表L中查找具有给定关键字值的元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//按值查找，找到数据域==e的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LNode <span style="color:#f92672">*</span><span style="color:#a6e22e">LocateElem</span>(LinkList L,ElemType e){
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//从第1个结点开始查找数据域为e的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!==</span>NULL <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> e)
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;		<span style="color:#75715e">//找到后返回该结点指针，否则返回NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p>最好情况:O(1)</p>
<p>最差情况/平均情况:O(n)</p>
</blockquote>
<p><strong>求表的长度</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//求表的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Length</span>(LinkList L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;		<span style="color:#75715e">//统计表长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> L;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        len<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>时间复杂度:O(n)</p>
</blockquote>
<h2 id="单链表的建立">单链表的建立
</h2><p><strong>尾插法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LNode,<span style="color:#f92672">*</span>LinkList;
</span></span><span style="display:flex;"><span>LinkList <span style="color:#a6e22e">LinkList_TailInsert</span>(LinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;					<span style="color:#75715e">//设置ElemType为整形
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    L <span style="color:#f92672">=</span> (LinkList)malloc(<span style="color:#66d9ef">sizeof</span>(LNode)); <span style="color:#75715e">//建立头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LNode <span style="color:#f92672">*</span>s,<span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> L;		<span style="color:#75715e">//r为表尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>x);			<span style="color:#75715e">//输入结点的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(x<span style="color:#f92672">!=</span><span style="color:#ae81ff">9999</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//输入9999表示结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));
</span></span><span style="display:flex;"><span>        s<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>        r<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>s;
</span></span><span style="display:flex;"><span>        r<span style="color:#f92672">=</span>s;			<span style="color:#75715e">//r指向新的表尾结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> L;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>头插法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LinkList_HeadInsert(LinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    LNode <span style="color:#f92672">*</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">=</span>(LinkList)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));		<span style="color:#75715e">//创建头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;						<span style="color:#75715e">//初始为空链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>x);						<span style="color:#75715e">//输入结点的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(x<span style="color:#f92672">!=</span><span style="color:#ae81ff">9999</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//输入9999表示结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        s <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));	<span style="color:#75715e">//创建新结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        s<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>        s<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        L<span style="color:#f92672">-</span>next<span style="color:#f92672">=</span>s;	<span style="color:#75715e">//将新结点插入表中，L为头指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> L;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="双链表">双链表
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DNode</span> <span style="color:#f92672">*</span>prior,<span style="color:#f92672">*</span>next;	<span style="color:#75715e">//前驱和后继指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}DNode, <span style="color:#f92672">*</span>DLinkList;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//初始化双链表(带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InitDLinkList</span>(DLinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (DNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(DNode));	<span style="color:#75715e">//分配一个头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">==</span>NULL)		<span style="color:#75715e">//内存不足,分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>prior <span style="color:#f92672">=</span> NULL;		<span style="color:#75715e">//头结点的prior永远指向NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;			<span style="color:#75715e">//头结点之后暂时还没有结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//在p结点之后插入s结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InsertNextDNode</span>(DNeode <span style="color:#f92672">*</span>p, DNode <span style="color:#f92672">*</span>s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL<span style="color:#f92672">||</span>s<span style="color:#f92672">==</span>NULL)		<span style="color:#75715e">//非法参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">!=</span>NULL)		<span style="color:#75715e">//如果p结点还有后继节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-</span>prior<span style="color:#f92672">=</span>s;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>prior<span style="color:#f92672">=</span>p;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//删除p的后继节点q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeleteNextDNode</span>(DNode <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    DNode <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;	<span style="color:#75715e">//找到p的后继结点q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;	<span style="color:#75715e">//p没有后继
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">!=</span>NULL)<span style="color:#960050;background-color:#1e0010">`</span>		<span style="color:#75715e">//q有后继结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prior<span style="color:#f92672">=</span>p;
</span></span><span style="display:flex;"><span>    free(q);		<span style="color:#75715e">//释放结点空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//双链表的遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//后向遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//前向遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>prior;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//前向遍历(跳过头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span>(p<span style="color:#f92672">-&gt;</span>prior<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>prior;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 时间复杂度:O(n)
</span></span></span></code></pre></div><h2 id="循环链表">循环链表
</h2><p><strong>循环单链表</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LNode, <span style="color:#f92672">*</span>LinkList;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化一个循环单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InitList</span>(LinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (LNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LNode));<span style="color:#75715e">//分配一个头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L;		<span style="color:#75715e">//头结点的next指向头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断循环单链表是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Empty</span>(LinkList L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断p结点是否为循环单链表的表尾结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isTail</span>(LinkList L,LNode <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">==</span>L)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>循环双链表</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//初始化空的循环双链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InitDLinkList</span>(DLinkList <span style="color:#f92672">&amp;</span>L){
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (DNode <span style="color:#f92672">*</span>)malloc(siezeof(DNode));<span style="color:#75715e">//分配一个头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>prior<span style="color:#f92672">=</span>L;
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断循环双链表是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Empty</span>(DLinkList L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">==</span>L)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断p结点是否是循环双链表的表尾结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isTail</span>(DLinkList L,DNode <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="静态链表">静态链表
</h2><p><strong>单链表</strong>：各个节点在内存中星罗棋布，散落天涯</p>
<p><strong>静态链表</strong>：分配一整片连续的内存空间，各个结点集中安置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 10  </span><span style="color:#75715e">// 静态链表的最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next;		<span style="color:#75715e">//下一个元素的数组下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next;
</span></span><span style="display:flex;"><span>}SLinkList[MaxSize];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testSLinkList</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> x;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;sizeX=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#66d9ef">sizeof</span>(x));
</span></span><span style="display:flex;"><span> 	
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> a[MaxiSize];
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;sizeA=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#66d9ef">sizeof</span>(a));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SLinkList b;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;sizeB=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#66d9ef">sizeof</span>(b));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//输出结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// sizeX=8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// sizeA=80
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// sizeB=80
</span></span></span></code></pre></div><blockquote>
<p>查找:O(n)</p>
</blockquote>
<h2 id="顺序表vs链表">顺序表VS链表
</h2><div class="table-wrapper"><table>
<thead>
<tr>
<th></th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑结构</td>
<td>线性结构</td>
<td>线性结构</td>
</tr>
<tr>
<td>物理结构</td>
<td>顺序存储,支持随机存取,存储密度高;大片连续空间分配不方便,改变容量不方便</td>
<td>链式存储,离散的空间分配方便,改变容量方便;不可随机存储,存储密度低</td>
</tr>
<tr>
<td>数据的运算</td>
<td>静态自动回收,动态手动free</td>
<td>遍历free</td>
</tr>
<tr>
<td>适用情况</td>
<td>表长可以估计,经常进行查询</td>
<td>表长难以估计,需要经常增删改查</td>
</tr>
</tbody>
</table></div>
<h1 id="栈和队列">栈和队列
</h1><h2 id="栈的基本概念">栈的基本概念
</h2><p><strong>栈</strong>(Stack)是只允许在一端进行插入或删除操作的线性表</p>
<p><strong>栈顶</strong>:允许进行插入和删除的一端</p>
<p><strong>栈底</strong>:不允许进行插入和删除的一端</p>
<p><strong>空栈</strong>:没有元素的栈</p>
<p>特点:后进先出(Last in First Out,LIFO)</p>
<p><strong>常考题型</strong>:n个不同元素进栈,出栈元素不同的排列的个数为$\frac{1}{n+1}C_{2n}^n$,上述公式称为卡特兰数,可采用数学归纳法证明.</p>
<h2 id="栈的顺序存储实现">栈的顺序存储实现
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    ElemType data[MaxSize];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> top;			<span style="color:#75715e">//栈顶指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SqStack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">&amp;</span>S){
</span></span><span style="display:flex;"><span>    S.top<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;			<span style="color:#75715e">//初始化栈顶指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断栈空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">StackEmpty</span>(SqStack S){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> S.top<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>;		
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//新元素入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Push</span>(SqStack <span style="color:#f92672">&amp;</span>S, ElemType x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(S.top<span style="color:#f92672">===</span>MaxSize<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//栈满,报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//一下两行可以简写为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//S.data[++S.top]=x;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    S.top<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    S.data[S.top]<span style="color:#f92672">=</span>x;	<span style="color:#75715e">//新元素入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出栈操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">&amp;</span>S,ElemType <span style="color:#f92672">&amp;</span>x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(S.top<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">=</span>S.data[S.top<span style="color:#f92672">--</span>];	<span style="color:#75715e">//栈顶元素先出栈,再将指针-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读取栈顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">&amp;</span>S,ElemType <span style="color:#f92672">&amp;</span>x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(S.top<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">=</span>S.data[S.top];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testStack</span>(){
</span></span><span style="display:flex;"><span>    SqStack S;		<span style="color:#75715e">//声明一个顺序栈(分配空间)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 后续操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//栈满条件:S,top = MaxSize
</span></span></span></code></pre></div><p><strong>共享栈</strong>:两个栈共享同一片空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    ElemType data[MaxSize];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> top0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> top1;
</span></span><span style="display:flex;"><span>}ShStack;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(ShStack <span style="color:#f92672">&amp;</span>S){
</span></span><span style="display:flex;"><span>    S.top0<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    S.top1<span style="color:#f92672">=</span>MaxSize;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//栈满的条件:top0+1=top1
</span></span></span></code></pre></div><h2 id="栈的链式存储">栈的链式存储
</h2><p><strong>定义</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//链栈的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Linknode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Linknode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}<span style="color:#f92672">*</span>LiStack;
</span></span></code></pre></div><h2 id="队列的基本概念">队列的基本概念
</h2><p><strong>队列</strong>(Queue):先进先出(First in first out,FIFO)</p>
<p><strong>重要术语</strong>:队头,队尾,空队列</p>
<h2 id="队列的顺序实现">队列的顺序实现
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//循环队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MaxSize 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    ElemType data[MaxSize];		<span style="color:#75715e">//用静态数组存放队列元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> front,rear		<span style="color:#75715e">//队头指针和队尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SqQueue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始时,队头,队尾指针指向0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Q.rear<span style="color:#f92672">=</span>Q.front<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">QueueEmpty</span>(SqQueue Q){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Q.rear<span style="color:#f92672">==</span>Q.front)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">EnQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q,ElemType x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>((Q.rear<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize<span style="color:#f92672">==</span>Q.front)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    Q.data[Q.rear]<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>    Q.rear<span style="color:#f92672">=</span>(Q.rear<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize;  <span style="color:#75715e">//队尾指针加1取模运算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//出队(删除一个队头元素,并用x返回)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeQueue</span>(SqQueue, <span style="color:#f92672">&amp;</span>Q,ElemType <span style="color:#f92672">&amp;</span>x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Q.rear<span style="color:#f92672">==</span>Q.front)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">//队空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    x<span style="color:#f92672">=</span>Q.data[Q.front];
</span></span><span style="display:flex;"><span>    Q.front<span style="color:#f92672">=</span>(Q.front<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize;	<span style="color:#75715e">//指针后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    retrun true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//获取队头元素的值,用x返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">GetHead</span>(SqQueue Q,ElemType <span style="color:#f92672">&amp;</span>x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Q.rear<span style="color:#f92672">==</span>Q.front)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">=</span>Q.data[Q.front];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testQueue</span>(){
</span></span><span style="display:flex;"><span>    SqQueue Q;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>判断队列已满/已空的方法</strong></p>
<ul>
<li>方法1
<ul>
<li>已满:rear+1==front</li>
<li>已空:rear==front</li>
</ul>
</li>
<li>方法2:设计size来表示当前队列的长度
<ul>
<li>已满:size==MaxSize</li>
<li>已空:size==0</li>
</ul>
</li>
<li>方法3:用tag来表示队列的上一次操作,每次删除成功,令tag=0;插入成功令tag=1;
<ul>
<li>已满:rear==front&amp;&amp;tag=1</li>
<li>已空:rear==front&amp;&amp;tag=0</li>
</ul>
</li>
</ul>
<h2 id="队列的链式实现">队列的链式实现
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//队列的链式实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkNode</span>{   <span style="color:#75715e">//链式队列结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}LinkNode;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{				<span style="color:#75715e">//链式队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LinkNode <span style="color:#f92672">*</span>front,<span style="color:#f92672">*</span>rear;	<span style="color:#75715e">//队列的队头和队尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LinkQueue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化队列(带头结点)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始时,front,rear 都指向头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Q.front<span style="color:#f92672">=</span>Q.rear<span style="color:#f92672">=</span>(LinkNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkNode));
</span></span><span style="display:flex;"><span>    Q.front<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IsEmpty</span>(LinkQueue Q){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Q.front<span style="color:#f92672">==</span>Q.rear)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//新元素入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">EnQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q,ElemType x){
</span></span><span style="display:flex;"><span>	LinkNode <span style="color:#f92672">*</span>s<span style="color:#f92672">=</span>(LinkNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkNode));
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>    Q.rear<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>s;			<span style="color:#75715e">//新结点插入到rear之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Q.rear<span style="color:#f92672">=</span>s;				<span style="color:#75715e">//修改表尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testLinkQueue</span>(){
</span></span><span style="display:flex;"><span>    LinkQueue Q;		<span style="color:#75715e">//声明一个队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InitQueue(Q);		<span style="color:#75715e">//初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//队列元素出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q,ElemType <span style="color:#f92672">&amp;</span>x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Q.front<span style="color:#f92672">==</span>Q.rear)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;		<span style="color:#75715e">//空队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LinkNode <span style="color:#f92672">*</span>p<span style="color:#f92672">=</span>Q.front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>data;			<span style="color:#75715e">//用变量x返回队头元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Q.front<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;	<span style="color:#75715e">//修改头结点的next指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(Q.rear<span style="color:#f92672">==</span>p)			<span style="color:#75715e">//此次是最后一个结点出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Q.rear<span style="color:#f92672">=</span>Q.front;		<span style="color:#75715e">//修改rear指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    free(p);				<span style="color:#75715e">//释放结点空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="双端队列">双端队列
</h2><p><img src="/%e5%8f%8c%e7%ab%af%e9%98%9f%e5%88%97.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="栈的应用--括号匹配">栈的应用&ndash;括号匹配
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 10  </span><span style="color:#75715e">//定义栈中元素的最大个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[MaxSize];		<span style="color:#75715e">//静态数组存放栈中元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> top;				<span style="color:#75715e">//栈顶指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SqStack;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">&amp;</span>S);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">StackEmpty</span>(SqStack S);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//新元素入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Push</span>(SqStack <span style="color:#f92672">&amp;</span>S,<span style="color:#66d9ef">char</span> x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//栈顶元素出栈,用x返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">&amp;</span>S,<span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">bracketCheck</span>(<span style="color:#66d9ef">char</span> str[],<span style="color:#66d9ef">int</span> length){
</span></span><span style="display:flex;"><span>    SqStack S;
</span></span><span style="display:flex;"><span>    InitStack(S);		<span style="color:#75715e">//初始化一个栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>length;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;(&#39;</span><span style="color:#f92672">||</span>str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;[&#39;</span><span style="color:#f92672">||</span>str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;{&#39;</span>){
</span></span><span style="display:flex;"><span>            Push(S,str[i]);<span style="color:#75715e">//扫描到左括号,入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(StackEmpty(S))<span style="color:#75715e">//扫描到右括号且目前栈空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">//匹配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cahr topElem;
</span></span><span style="display:flex;"><span>            Pop(S,topElem);	<span style="color:#75715e">//栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;)&#39;</span><span style="color:#f92672">&amp;&amp;</span>topElem<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;(&#39;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;]&#39;</span><span style="color:#f92672">&amp;&amp;</span>topElem<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(str[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;}&#39;</span><span style="color:#f92672">&amp;&amp;</span>topElem<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;{&#39;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> StackEmpty(S); <span style="color:#75715e">//检索全部括号后,栈空说明匹配成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="栈的应用--表达式求值">栈的应用&ndash;表达式求值
</h2><p><strong>三种算术表达式</strong></p>
<ul>
<li>前缀表达式(波兰表达式)**</li>
</ul>
<blockquote>
<p><strong>右优先原则</strong></p>
<p>只要右边的运算符能先计算,就优先算右边的</p>
<p>从右往左扫描</p>
<p>扫描到操作数则压入栈,继续扫描</p>
<p>扫描到运算符,则弹出两个栈顶元素,执行相应的运算,运算结果压回栈顶,继续扫描(注意:先出栈的是<strong>左操作数</strong></p>
</blockquote>
<ul>
<li>中缀表达式</li>
<li>后缀表达式(逆波兰表达式)</li>
</ul>
<blockquote>
<p><strong>左优先原则</strong></p>
<p>只要左边的运算符能先计算,就优先算左边的</p>
<p>从左往右扫描</p>
<p>扫描到操作数则压入栈,继续扫描</p>
<p>扫描到运算符,则弹出两个栈顶元素,执行相应的运算,运算结果压回栈顶,继续扫描(注意:先出栈的是<strong>右操作数</strong></p>
</blockquote>
<p><strong>中缀表达式转后缀表达式</strong></p>
<p>初始化一个栈,用于保存{%label 暂时还蹦年确定运算顺序的运算符 green%}</p>
<p>从左到右处理各个元素,直到末尾.可能遇到三种情况:</p>
<ol>
<li>遇到{%label 操作数 green%}.直接加入后缀表达式.</li>
<li>遇到{%label 界限符 green%}.遇到&rdquo;(&ldquo;直接入栈;遇到&rdquo;)&ldquo;则依次弹出栈内运算符并加入后缀表达式,直到弹出&rdquo;(&ldquo;位置.注意:&rdquo;(&ldquo;不加入后缀表达式</li>
<li>遇到{%label 运算符 green%}.依次弹出栈中优先级高于或等于当前运算符的所有运算符,并加入后缀表达式,若碰到&rdquo;(&ldquo;或栈空则停止.之后再把当前运算符入栈.</li>
<li>按上述方法处理完所有字符后,将栈中剩余运算符依次弹出,并加入后缀表达式.</li>
</ol>
<h2 id="栈的应用--递归">栈的应用&ndash;递归
</h2><p><strong>函数调用背后的过程</strong></p>
<p>函数调用时,需要用一个栈存储:</p>
<ol>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ol>
<p>适合用&quot;递归&quot;算法解决:可以把原始问题转换为{%label 属性相同 green%},但{%label 规模较小的问题 green%}</p>
<h2 id="队列的应用--树的层次遍历">队列的应用&ndash;树的层次遍历
</h2><h2 id="队列的应用--图的广度优先遍历">队列的应用&ndash;图的广度优先遍历
</h2><h2 id="队列在操作系统中的应用">队列在操作系统中的应用
</h2><p>FCFS(First Come First Service,先来先服务)</p>
<h2 id="特殊矩阵的压缩存储">特殊矩阵的压缩存储
</h2><p><strong>一维数组的存储结构</strong></p>
<p>各个数组元素大小相同，且在物理上连续存放，已知起始地址即可得到其他地址</p>
<p><strong>二维数组的存储结构</strong></p>
<ul>
<li>行优先存储</li>
<li>列优先存储</li>
</ul>
<p><strong>普通矩阵的存储</strong></p>
<p>使用二维数组</p>
<p><strong>对称矩阵的压缩存储</strong></p>
<p>只存储主对角线+下/上三角区域</p>
<p><strong>三角矩阵的压缩存储</strong></p>
<p>按照行优先原则将绿色区元素存入一维数组中。并在最后一个位置存储常量c</p>
<p><strong>三对角矩阵的压缩存储</strong></p>
<p>按行优先(或列优先)原则，只存储带状部分</p>
<p><strong>稀疏矩阵的压缩矩阵</strong></p>
<ul>
<li>顺序存储&ndash;三元组&lt;行，列，值&gt;</li>
<li>十字链表法</li>
</ul>
<h1 id="串">串
</h1><h2 id="串的定义和基本操作">串的定义和基本操作
</h2><p><strong>串</strong>，即字符串(String)是由零个或多个字符组成的有限序列。</p>
<p><strong>空串</strong>：长度为0的串</p>
<p><strong>子串</strong>：串中任意各连续的字符组成的子序列。</p>
<p><strong>主串</strong>：包含子串的串</p>
<p><strong>子串在主串中的位置</strong>：子串的第一个字符在主串中的位置</p>
<hr>
<p><strong>串的基本操作</strong></p>
<ul>
<li>StrAssign(&amp;T,chars):赋值操作。把串T赋值为chars</li>
<li>StrCopt(&amp;T,S):复制操作。由串S复制得到串T</li>
<li>StrEmpty(S):判空操作。若S为空串，则返回true,否则，返回false</li>
<li>StrLength(S):求串长。返回串S的元素个数。</li>
<li>ClearString(&amp;S):清空操作。将S清为空串</li>
<li>DestroyString(&amp;S):销毁串，将串S的存储空间回收</li>
<li>Concat(&amp;T,S1,S2):串连接。用T返回S1和S2连接成的新串</li>
<li>SubString(&amp;Sub,S,pos,len):求子串，用Sub返回串S的第pos个字符起长度为len的子串</li>
<li>Index(S,T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则返回0</li>
<li>StrCompare(S,T):若S&gt;T,则返回值&gt;0,若S=T,则返回值=0,若S&lt;T，则返回值&lt;0</li>
</ul>
<p><strong>字符集编码</strong></p>
<p>英文字符-ASCII字符集</p>
<p>中英文&ndash;Unicode字符集</p>
<p>基于同一字符集，可以有多种编码方案。如UTF-8,UTF-16</p>
<p><strong>拓展：乱码问题</strong></p>
<h2 id="串的存储结构">串的存储结构
</h2><p><strong>顺序存储</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MAXLEN 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch[MAXLEN];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}SString;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ch;	<span style="color:#75715e">//按串长分配存储区,ch指向串的基地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;	<span style="color:#75715e">//串的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}HString;<span style="color:#75715e">//动态数组实现(堆分配存储)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>HString S;
</span></span><span style="display:flex;"><span>S.ch <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(MAXLEN <span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
</span></span><span style="display:flex;"><span>S.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p><strong>链式存储</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StringNode</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StringNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}StringNode, <span style="color:#f92672">*</span>String;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StringNode</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">4</span>];	<span style="color:#75715e">//每个结点存多个字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StringNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}StringNode, <span style="color:#f92672">*</span>String;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MAXLEN 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch[MAXLEN];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}SString;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//求子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SubString</span>(SString <span style="color:#f92672">&amp;</span>Sub, SString S,<span style="color:#66d9ef">int</span> pos,<span style="color:#66d9ef">int</span> len){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//子串范围越界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(pos<span style="color:#f92672">+</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>S.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>pos;i<span style="color:#f92672">&lt;</span>pos<span style="color:#f92672">+</span>len;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        Sub.ch[i<span style="color:#f92672">-</span>pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> S.ch[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Sub.length <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="朴素模式匹配算法">朴素模式匹配算法
</h2><p>被找的是主串，要找的目标是模式串</p>
<p><strong>字符串模式匹配</strong>：在主串中找到与模式串相同的子串，并返回其所在位置</p>
<p>找到主串所有与模式串长度相等的子串与模式串进行匹配</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index</span>(SString S,SString T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>S.length <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;=</span>T.length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(S.ch[i]<span style="color:#f92672">==</span>T.ch[i]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>; <span style="color:#75715e">//继续比较后续字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">=</span>i<span style="color:#f92672">-</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;	<span style="color:#75715e">//指针后退重新开始匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;</span>T.length)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i<span style="color:#f92672">-</span>T.length;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="kmp匹配算法">KMP匹配算法
</h2><p><strong>改进思路</strong>:主串指针不回溯,只有{%label 模式串指针回溯 green%}</p>
<p><img src="/KPM%e7%ae%97%e6%b3%95.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index_KMP</span>(SString S,SString T,<span style="color:#66d9ef">int</span> next[]){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>S.length<span style="color:#f92672">&amp;&amp;</span>j<span style="color:#f92672">&lt;</span>T.length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>S.ch[i]<span style="color:#f92672">==</span>T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;	<span style="color:#75715e">//继续比较后继字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">=</span>next[j];<span style="color:#75715e">//模式串向右移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;</span>T.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> i<span style="color:#f92672">-</span>T.length;	<span style="color:#75715e">//匹配成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>求next数组</strong></p>
<p><strong>串的前缀</strong>:包含第一个字符,且不包含最后一个字符的子串</p>
<p><strong>串的后缀</strong>:包含最后一个字符,且不包含第一个字符的子串</p>
<p>当第j个字符匹配失败，由前1~j-1个字符组成的串记为S，则{%label next[j]=S的最长相等前后缀长度+1 green%}，可推导出next[2]=1</p>
<p>特别地,next[1]=0</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//求模式串T的next数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_next</span>(SString T,<span style="color:#66d9ef">int</span> next[]){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    next[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>T.length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>T.ch[i]<span style="color:#f92672">=</span>T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//若pi=pj，则next[j+1]=next[j]+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            next[i]<span style="color:#f92672">=</span>j;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//否则令j=next[j],循环继续
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            j<span style="color:#f92672">=</span>next[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//KMP算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index_KMP</span>(SString S,SString T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next[T.length<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    get_next(T,next);	<span style="color:#75715e">//求模式串的next数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>S.length<span style="color:#f92672">&amp;&amp;</span>j<span style="color:#f92672">&lt;=</span>T.length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>S.ch[i]<span style="color:#f92672">==</span>T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;			<span style="color:#75715e">//继续比较向后的字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">=</span>next[j];		<span style="color:#75715e">//模式串向右移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;</span>T.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> i<span style="color:#f92672">-</span>T.length;	<span style="color:#75715e">//匹配成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="树">树
</h1><h2 id="树的定义和基本术语">树的定义和基本术语
</h2><blockquote>
<p>除了根节点外，任何一个结点都有且仅有一个前驱</p>
</blockquote>
<p><strong>术语</strong>：祖先结点，子孙结点，双亲结点(父节点),子结点，兄弟结点，堂兄弟结点</p>
<p><strong>路径</strong>：只能从上往下，经过了几条边，长度就是几</p>
<p><strong>属性</strong></p>
<ul>
<li>结点的层次(深度):从上往下数</li>
<li>结点的高度：从下往上数</li>
<li>树的高度(深度):总共多少层</li>
<li>结点的度：有几个孩子(分支)</li>
<li>树的度：各结点的度的最大值</li>
</ul>
<p><strong>有序树VS无序树</strong></p>
<ul>
<li>有序树：从逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</li>
<li>无序树：从逻辑上看，数中结点的各子树从左至右是无次序的，可以互换</li>
</ul>
<p><strong>森林</strong>：m课互不相交的树的集合</p>
<h2 id="树的性质">树的性质
</h2><ul>
<li>树的结点数=总度数+1(即所有子孙结点+根节点)</li>
<li>度为m的树，m叉树的区别</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>度为m的树</th>
<th>m叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意结点的度&lt;=m,(最多m个孩子)</td>
<td>任意结点的度&lt;=m(最多m个孩子)</td>
</tr>
<tr>
<td>至少有一个结点度=m(有m个孩子)</td>
<td>允许所有结点的度都&lt;m</td>
</tr>
<tr>
<td>一定是非空数，至少有m+1个结点</td>
<td>可以是空树</td>
</tr>
</tbody>
</table></div>
<ul>
<li>度为m的树第i层至多有$m^{i-1}$个结点</li>
</ul>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83.png"
	width="909"
	height="511"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83_hu10261060283598385148.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83_hu387611944553164644.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<ul>
<li>
<p>高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点</p>
</li>
<li>
<p>高度为h的m叉树至少有h个结点</p>
</li>
<li>
<p>高度为h，度为m的树至少有h+m-1个结点</p>
</li>
<li>
<p>具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1)+1)\rceil$</p>
</li>
</ul>
<h2 id="二叉树的定义和基本概念">二叉树的定义和基本概念
</h2><p><strong>特点</strong>：</p>
<ul>
<li>每个结点至多只有两棵子树</li>
<li>左右子树不能颠倒(二叉树是有序树)</li>
</ul>
<p><strong>特殊二叉树</strong></p>
<ul>
<li>满二叉树：一棵高度为h,且含有$2^h-1$个结点的二叉树
<ul>
<li>只有最后一层有叶子结点</li>
<li>不存在度为1的结点</li>
<li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1;结点i的父节点为[i/2](如果有的话)</li>
</ul>
</li>
<li>完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时，称为完全二叉树。
<ul>
<li>只有最后两层可能有叶子节点</li>
<li>最多只有一个度为1的结点</li>
<li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1;结点i的父节点为$\lfloor i的父节点 \rfloor$(如果有的话)</li>
<li>i&lt;=[n/2]为分支节点，i&gt;[n/2]为叶子节点</li>
</ul>
</li>
<li>二叉排序树
<ul>
<li>左子树上所有结点的关键字均小于根节点的关键字</li>
<li>右子树上所有结点的关键字均大于根节点的关键字</li>
<li>左右子树又各是一棵二叉排序树</li>
</ul>
</li>
<li>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</li>
</ul>
<h2 id="二叉树的性质">二叉树的性质
</h2><p><strong>常考性质</strong></p>
<ul>
<li>设非空二叉树中度为0,1,2的结点个数分别为$n_0,n_1,n_2$,则$n_0=n_2+1$
<ul>
<li>假设树中结点总数为n，则
<ul>
<li>$n=n_0+n_1+n_2$</li>
<li>$n=n_1+2n_2+1$结点数等于总度数+1</li>
</ul>
</li>
</ul>
</li>
<li>二叉树第i层最多有$2^{i-1}$个结点</li>
<li>高度为h的二叉树至多有$2^h-1$个结点</li>
</ul>
<p><strong>完全二叉树常考性质</strong></p>
<ul>
<li>具有n个结点的完全二叉树高度h为$\lceil log_2(n+1)\rceil 或\lfloor log_2n\rfloor+1$</li>
</ul>
<p><img src="/%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e6%80%a7%e8%b4%a8.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>对于完全二叉树，可以由结点数n推出度为0,1,2的结点个数为$n_0,n_1,n_2$</li>
</ul>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A82.png"
	width="909"
	height="510"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A82_hu13748560280736970044.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A82_hu902841069468168753.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="178"
		data-flex-basis="427px"
	
></p>
<h2 id="二叉树的存储结构">二叉树的存储结构
</h2><p><strong>完全二叉树顺序存储</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span>{
</span></span><span style="display:flex;"><span>    ElemType value;	<span style="color:#75715e">//结点中的数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> isEmpty;	<span style="color:#75715e">//结点是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//定义一个长度为MaxSize的数组t，按照从上至下，从左至右的顺序依次存储完全二叉树中的各个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化设置各节点为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TreeNode t[MaxSize];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>MaxSize;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    t[i].isEmpty<span style="color:#f92672">=</span>true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//可以空缺t[0]来使数组下标与二叉树序号一一对应
</span></span></span></code></pre></div><p>几个重要常考的基本操作</p>
<ul>
<li>i的左孩子  &ndash;2i</li>
<li>i的右孩子  &ndash;2i+1</li>
<li>i的父节点  &ndash;$\lfloor i/2 \rfloor$</li>
<li>i所在的层次 &mdash;$\lceil log_2(n+1) \rceil 或 \lfloor log_2n \rfloor +1$</li>
</ul>
<p>若完全二叉树中共有n个结点，则</p>
<ul>
<li>判断i是否有左孩子 &ndash;2i&lt;=n？</li>
<li>判断i是否有右孩子 &ndash;2i+1&lt;=n?</li>
<li>判断i是否是叶子/分支结点? &ndash;i&gt;$\lfloor n/2 \rfloor$</li>
</ul>
<blockquote>
<p>普通二叉树一定要把树的结点编号和完全二叉树对应起来</p>
</blockquote>
<p><strong>二叉树的链式存储</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//二叉树的结点(链式存储)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ElemType</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>}BiTNode,<span style="color:#f92672">*</span>BiTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//定义一棵空树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BiTree root <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><blockquote>
<p>n个结点的二叉链表共有n+1个空链域</p>
<p>因为n个结点总共有2n个指针域，除了根节点外，每个结点头上都有一个指针，所以有效指针为n-1个，故空指针为n+1个</p>
</blockquote>
<p>如果实际需求需要经常查找父节点的话，可以定义一个指向父节点的指针(三叉链表)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>lchild,<span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>parent;
</span></span><span style="display:flex;"><span>}BiTNode,<span style="color:#f92672">*</span>BiTree;
</span></span></code></pre></div><h2 id="二叉树的先中后序遍历">二叉树的先中后序遍历
</h2><p><strong>二叉树的递归特性</strong></p>
<ul>
<li>要么是个空二叉树</li>
<li>要么就是“根节点+左子树+右子树&rdquo;
<ul>
<li>先序遍历:根左右(NLR)：第一次路过访问</li>
<li>中序遍历:左根右(LNR)：第二次路过访问</li>
<li>后序遍历:左右根(LRN)：第三次路过访问</li>
</ul>
</li>
</ul>
<h2 id="二叉树的层次遍历">二叉树的层次遍历
</h2><p><strong>算法思想</strong></p>
<ul>
<li>初始化一个辅助队列</li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾</li>
<li>重复第三条直至队列为空</li>
</ul>
<h2 id="由遍历序列来构造二叉树">由遍历序列来构造二叉树
</h2><p>必须有中序遍历，再加一个前序/后序遍历</p>
<h2 id="线索二叉树">线索二叉树
</h2><p><strong>找到p结点的中序遍历序列前驱</strong></p>
<ul>
<li>从根节点触发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个被访问的结点
<ul>
<li>当q==p时，pre为前驱</li>
<li>当pre=q时，q为后继</li>
</ul>
</li>
</ul>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png"
	width="914"
	height="513"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91_hu11951995564375077401.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91_hu1569172854897370677.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="178"
		data-flex-basis="427px"
	
></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//二叉树的结点(链式存储)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>lchild,<span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>}BiTNode,<span style="color:#f92672">*</span>BiTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//线索二叉树结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ThreadNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ThreadNode</span> <span style="color:#f92672">*</span>lchild,<span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ltag,rtag;	<span style="color:#75715e">//左右线索标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}ThreadNode, <span style="color:#f92672">*</span>ThreadTree;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//tag==0,表示指向孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//tag==1,表示指向线索
</span></span></span></code></pre></div><h2 id="二叉树的线索化">二叉树的线索化
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//中序遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InOrder</span>(BiTree T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>        InOrder(T<span style="color:#f92672">-&gt;</span>lchild);	<span style="color:#75715e">//递归遍历左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visit(T);
</span></span><span style="display:flex;"><span>        InOrder(T<span style="color:#f92672">-&gt;</span>rchild);	<span style="color:#75715e">//递归遍历右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//访问结点q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(BiTNode <span style="color:#f92672">*</span>q){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>q)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#f92672">=</span> pre;<span style="color:#75715e">//找到p的前驱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        pre<span style="color:#f92672">=</span>q;	<span style="color:#75715e">//移动pre访问当前结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//辅助全局变量，用于查找结点p的前驱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BiTNode <span style="color:#f92672">*</span>p;		<span style="color:#75715e">//p指向目标结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BiTNode <span style="color:#f92672">*</span>pre<span style="color:#f92672">=</span>NULL; <span style="color:#75715e">//指向当前访问结点的前驱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BiTNode <span style="color:#f92672">*</span><span style="color:#66d9ef">final</span><span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//用于记录最终结果   
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//线索二叉树结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ThreadNode</span>{
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ThreadNode</span> <span style="color:#f92672">*</span>lchild,<span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ltag,rtag;	<span style="color:#75715e">//左右线索标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}ThreadNode, <span style="color:#f92672">*</span>ThreadTree;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//中序遍历二叉树,一边遍历一边线索化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InThread</span>(ThreadTree T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>        InThread(T<span style="color:#f92672">-&gt;</span>lchild);<span style="color:#75715e">//中序遍历左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visit(T);			<span style="color:#75715e">//访问根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        InThread(T<span style="color:#f92672">-&gt;</span>rchild);<span style="color:#75715e">//中序遍历右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(ThreadNode <span style="color:#f92672">*</span>q){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">==</span>NULL){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//左子树为空,建立前驱线索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        q<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>pre;
</span></span><span style="display:flex;"><span>        q<span style="color:#f92672">-&gt;</span>ltag<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pre<span style="color:#f92672">!=</span>NULL<span style="color:#f92672">&amp;&amp;</span>pre<span style="color:#f92672">-&gt;</span>child<span style="color:#f92672">==</span>NULL){
</span></span><span style="display:flex;"><span>        pre<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;	<span style="color:#75715e">//建立前驱节点的后继线索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pre<span style="color:#f92672">-&gt;</span>rtag<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">=</span>q;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//全局变量pre,指向当前访问结点的前驱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadNode <span style="color:#f92672">*</span>pre<span style="color:#f92672">=</span>NULL;
</span></span></code></pre></div><h2 id="在线索二叉树中寻找前驱后继">在线索二叉树中寻找前驱后继
</h2><p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E9%A9%B1.png"
	width="912"
	height="508"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E9%A9%B1_hu10930260627634312829.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E9%A9%B1_hu11851466791293938503.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="179"
		data-flex-basis="430px"
	
></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后序线索二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>找前驱</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>找后继</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
</tbody>
</table></div>
<h2 id="树的存储结构">树的存储结构
</h2><p><strong>双亲表示法</strong>(顺序存储)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MAX_TREE_SIZE 100		</span><span style="color:#75715e">//树中最多结点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    ElemType data;				<span style="color:#75715e">//数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> parent;					<span style="color:#75715e">//双亲位置域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}PTNode;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    PTNode nodes[MAX_TREE_SIZE];	<span style="color:#75715e">//双亲表示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n;							<span style="color:#75715e">//结点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>孩子表示法</strong>(顺序+链式存储)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CTNode</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> child;		<span style="color:#75715e">//孩子结点在数组中的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CTNode</span> <span style="color:#f92672">*</span>next;		<span style="color:#75715e">//下一个孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CTNode</span> <span style="color:#f92672">*</span>firstChild;		<span style="color:#75715e">//第一个孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}CTBox;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    CTBox nodes[MAX_TREE_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,r;	<span style="color:#75715e">//结点数和根的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}CTree;
</span></span></code></pre></div><p><strong>孩子兄弟表示法</strong>(链式存储)</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96.png"
	width="911"
	height="518"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96_hu4117955765991657832.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96_hu3412925120002988291.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="175"
		data-flex-basis="422px"
	
></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png"
	width="904"
	height="508"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_hu14124866674247832561.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_hu13312112517529972317.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="427px"
	
></p>
<p><strong>森林和二叉树的转化</strong></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png"
	width="912"
	height="519"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_hu333040311036453107.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_hu3486382918527177016.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="175"
		data-flex-basis="421px"
	
></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97.png"
	width="911"
	height="513"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97_hu6312503530022063466.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97_hu9017238123216037324.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<h2 id="树和森林的遍历">树和森林的遍历
</h2><p><strong>树的先根遍历</strong>:深度优先遍历</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树的先根遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrder</span>(TreeNode <span style="color:#f92672">*</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(R<span style="color:#f92672">!==</span>NULL){
</span></span><span style="display:flex;"><span>        visit(R);	<span style="color:#75715e">//访问根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(R还有下一个子树T)
</span></span><span style="display:flex;"><span>            PreOrder(T);	<span style="color:#75715e">//先根遍历下一棵子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>树的先根遍历序列与这棵树对应的二叉树的先序序列相同</p>
</blockquote>
<p><strong>树的后根遍历</strong>:深度优先遍历</p>
<p><img src="/%e5%90%8e%e6%a0%b9%e9%81%8d%e5%8e%86.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>树的层次遍历</strong>(队列实现):广度优先遍历</p>
<ul>
<li>若树为空,则根节点入队</li>
<li>若队列非空,队头元素出队并访问,同时将该元素的孩子依次入队</li>
<li>重复2直到队列为空</li>
</ul>
<p><strong>森林的先序遍历</strong></p>
<ul>
<li>若森林为非空,则按照如下规则进行遍历</li>
<li>访问森林中第一棵树的根节点</li>
<li>先序遍历第一棵树中根节点的子树森林</li>
<li>先序遍历剩余的树构成的森林</li>
</ul>
<p><strong>森林的中序遍历</strong></p>
<h2 id="哈夫曼树">哈夫曼树
</h2><p><strong>概念</strong></p>
<ul>
<li>结点的权:有某种显示含义的数值(如:表示结点的重要性等)</li>
<li>结点的带权路径长度:从树的跟结点到该结点的路径长度(经过的边数)与该节点上权值的乘积</li>
<li>树的带权路径长度:树中所有叶子节点的带权路径长度之和(WPL,Weight Path Length)
<ul>
<li>$\sum\limits _{i=1}^n w_il_i$</li>
</ul>
</li>
</ul>
<p>在含由n个带权叶节点的二叉树中,其中{%label 带权路径长度(WPL)最小的二叉树 green%}称为{%label 哈夫曼树 red%},也称为最优二叉树</p>
<p><strong>哈夫曼树的构造</strong></p>
<p>给定n个权值分别为$w_1,w_2,&hellip;w_n$的结点,构造哈夫曼树的算法描述如下:</p>
<ul>
<li>将这n个结点分别作为n棵仅含一个结点的二叉树,构成森林F</li>
<li>构造一个新结点,从F中选取两棵根节点权值最小的树作为新结点的左右子树,并且将新结点的权值置为左右子树根结点的权值之和</li>
<li>从F中删除刚才选出的两棵树,同时将新得到的树加入F中</li>
<li>重复2,3步骤,直到F中只剩下一棵树为止.</li>
</ul>
<p><strong>哈夫曼树的性质</strong></p>
<ul>
<li>每个初始节点最终都成为叶节点,且权值越小的结点到根节点的路径长度越大</li>
<li>哈夫曼树的节点总数为2n-1(初始n个结点,每次两两合并产生一个新的结点,合并n-1次,故产生n-1个新结点)</li>
<li>哈夫曼树中不存在度为1的结点</li>
<li>哈夫曼树不唯一</li>
</ul>
<p><strong>哈夫曼编码</strong></p>
<p>固定长度编码:每个字符用相等长度的二进制位表示</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"
	width="909"
	height="511"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81_hu3123648040864467045.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81_hu1586821986323822255.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<p>可变长度编码:允许对不同字符用不等长的二进制位表示</p>
<p>若没有一个编码时另一个编码的前缀,则称这样的编码为{%label 前缀编码 green%}</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%812.png"
	width="916"
	height="515"
	srcset="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%812_hu14395903881753404017.png 480w, /post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%812_hu15762028672777984783.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<h2 id="并查集">并查集
</h2><h1 id="图">图
</h1><h2 id="图的基本概念">图的基本概念
</h2><p><strong>定义</strong>:图G是由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集合；E(G)表示图G中各顶点之间的关系(边)集合。用$|V|$表示图G中顶点的个数，也成为图G的阶．用$|E|$表示图G中边的条数.</p>
<p>若E是无向边(简称为边)的有限集合时,则图G为无向图.边是顶点的无序对.</p>
<ul>
<li>顶点v的度是指依附于该点的边的条数</li>
<li>顶点v到顶点w有路径存在,则称v和w是联通的</li>
<li>若图G中任意两个顶点之间是联通的,则称G为{%label 连通图 green%},否则为非连通图</li>
<li>有n个顶点的连通图G至少有n-1条边.有n个顶点的非连通图F最多有$C_{n-2}^2$条边.</li>
<li>无向图中的{%label 极大连通子图 green%}称为{%label 连通分量 green%}</li>
<li>连通图的{%label 生成树 green%}是包含图中全部顶点的一个极小的连通子图.</li>
<li>在非连通图中,连通分量的生成树构成了非连通图的{%label 生成森林 green%}</li>
<li>无向完全图:无向图中任意两个顶点之间都存在边</li>
</ul>
<p>若E是有向边(也称为弧)的有限集合时,则图G为有向图．弧是顶点的有序对，记为$&lt;v,w&gt;$,其中v称为{%label 弧尾 green%},w称为{%label 弧头 green%}.$&lt;v,w&gt;$称为从顶点v到顶点w的弧.</p>
<ul>
<li>入度是指以顶点v为终点的有向边的数目,记为ID(v)</li>
<li>出度是指以顶点v为起点的有向边的数目,记为OD(v)</li>
<li>顶点v的度等于其入度和出度之和.</li>
<li>在具有n个顶点,e条弧的有向图中,$\sum_{i=1}^n ID(v_i)= \sum_{i=1}^n OD(v_i)=e$</li>
<li>若&lt;v,w&gt;和&lt;w,v&gt;均存在,则这两个顶点是强连通的.</li>
<li>若图G中任意两个顶点都是强连通的,则称为强连通图.</li>
<li>含由n个顶点的强连通图至少有n条边(形成回路).</li>
<li>有向图中的{%label 极大强连通子图 green%}称为有向图的强连通分量.</li>
<li>有向完全图:有向图中任意两个顶点之间都存在方向相反的两条弧.</li>
</ul>
<p><strong>简单图</strong>:</p>
<ul>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
</ul>
<p><strong>多重图</strong>:</p>
<ul>
<li>图G中某两个结点之间的边数多于一条,又允许顶点通过同一条边和自己关联,则G为多重图.</li>
</ul>
<p><strong>路径</strong>:顶点$v_p$到顶点$v_q$之间的一条路径是指顶点序列,$v_p,v_{i_1},v_{i_2},v_{i_3},&hellip;v_q$</p>
<p><strong>回路</strong>(环):第一个顶点和最后一个顶点相同的路径</p>
<p><strong>简单路径</strong>:在路径序列中,顶点不重复出现的路径</p>
<p><strong>简单回来</strong>:除第一个和最后一个顶点外,其余顶点不重复出现的回路称为简单回路.</p>
<p><strong>路径长度</strong>:路径上边的数目</p>
<p><strong>点到点的距离</strong>:从顶点u出发到顶点v的最短路径若存在,则称此路径的长度为从u到v的距离.若不存在,则记该距离为无穷.$\infty$</p>
<p><strong>子图</strong>:设有两个图G=(V,E)和$G^{&rsquo;}=(V^{&rsquo;},E^{&rsquo;})$,若$V^{&rsquo;}$是V的子集,且$E^{&rsquo;}$是E的子集,则称$G^{&rsquo;}$是G的子图.</p>
<p><strong>生成子图</strong>:若有满足$V(G^{&rsquo;})=V(G)$的子图$G^{&rsquo;}$,则称其为生成子图.</p>
<p><strong>边的权</strong>:在一个图中,每条边都可以标注上具有某种含义的数值,该数值称为该边的权值.</p>
<p><strong>带权图/网</strong>:边上带有权值的图称为带权图,也称为网.</p>
<p><strong>带权路径长度</strong>:当图是带权图时,一条路径上所有边的权值之和,称为该路径的带权路径长度.</p>
<h2 id="邻接矩阵法">邻接矩阵法
</h2><p>邻接矩阵</p>
<h2 id="十字链表邻接多重表">十字链表，邻接多重表
</h2><h2 id="图的基本操作">图的基本操作
</h2><h2 id="图的广度优先遍历">图的广度优先遍历
</h2>
</section>


    <footer class="article-footer">
    

    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 马嘉路个人博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
